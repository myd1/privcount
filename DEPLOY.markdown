# Deployment

First, make sure you have downloaded and installed the latest version of
PrivCount. If you are running a data collector, also download, compile,
install, and launch the latest version of the Tor PrivCount patch.

See INSTALL.markdown for details.

## Machine Uptime

If you have automatic updates turned on, turn off automatic restarts.
Restarting during a collection round will cause the round to fail. Updating
some dependencies during a round might also cause the round to fail, so you
may want to subscribe to security announcements for your OS/distribution, and
apply updates manually during a collection round.

## Tally Server

### Configuration

#### Listen Address

Choose an IP address and port that is accessible on the Internet.

Add the following lines to the tally server config.yaml:

```
tally_server:
    listen_port: port
```

Send the following lines to the Share Keepers and Data Collectors for their
config.yaml:

```
share_keeper:
    tally_server_info:
        ip: 'IP address'
        port: port

data_collector:
    tally_server_info:
        ip: 'IP address'
        port: port
```

#### Counter Configuration

Ask the Data Collectors for their relay fingerprints. Some noise weight schemes
also need to know which physical machine each fingerprint is located on.

Configure the counters for this round, and the noise amounts for those
counters:

```
tally_server:
    counters: 'counters.bins.yaml'
    noise: 'counters.noise.yaml'
    noise_weight:
        'FACADE0000000000000000000123456789ABCDEF': 1.0
        '3DEADBEEF012345678900000000000000DEADC00': 1.0
```

If you want to collect a traffic model, configure it as well:

```
tally_server:
    traffic_model: 'traffic.model.json'
    traffic_noise: 'traffic.noise.yaml'
```

Be careful collecting and releasing PrivCount results: the configured noise
must protect a typical user's activity over a long enough period.
(We use 10 minutes.) And the collection period must be long enough to aggregate
usage from many users (we use multiple days or weeks).

PrivCount protects multiple collections as long as there is a delay between
collections with different noise values. See "Round Start Checks" in
doc/CounterChecks.markdown for details.

PrivCount is not designed for automated collection and results release: a long
enough series of results can identify the activity of a single user.

#### Collection Configuration

Configure the start thresholds and collection period (in seconds):

```
tally_server:
    sk_threshold: 5
    dc_threshold: 2
    collect_period: 604800
    delay_period: 86400
```

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, send it to the Share Keepers and Data Collectors.

See doc/CounterChecks.markdown for more details.

### First Run

After configuring the Tally Server, run PrivCount in tally server mode so that
it generates keys:

    screen
    source venv/bin/activate
    privcount ts config.yaml 2>&1 | tee -a ts.log

### Launch on Boot

If you are using cron, you can use dist/run_privcount.sh to start privcount:

    crontab -l > crontab.old
    cat crontab.old dist/crontab.privcount | crontab
    # Edit the crontab for type of node you want to launch
    crontab -e

Or you can use your distribution's service configuration to launch privcount.

### Autogenerated Keys

You MUST NOT use test keys for deployment: generate new keys for each network.

On first run, PrivCount creates the keys that it needs to run:

The TallyServer creates a RSA key pair for SSL encryption:
    * no configuration is required: clients do not check this key.

The TallyServer creates a PrivCount secret handshake key:
    * each ShareKeeper and DataCollector needs to know this key to
      successfully handshake with the TallyServer.
    * this is a symmetric key: it MUST be encrypted in transit to Share Keepers
      and Data Collectors.
    * encrypt, sign, and send the file privcount.secret_handshake.yaml to each
      Share Keeper and Data Collector.

See doc/PrivCountAuthentication.markdown for more details.

## Share Keepers

### Configuration

#### Tally Server Address

Add the following Tally Server details to the config.yaml:

```
share_keeper:
    tally_server_info:
        ip: 'IP address'
        port: port
```

#### Key Configuration

Place the privcount.secret_handshake.yaml file from the Tally Server in the
Share Keeper's working directory.

See doc/PrivCountAuthentication.markdown for more details.

#### Collection Configuration

```
share_keeper:
    delay_period: 86400
```

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, it should be the same as the Tally Server's.

See doc/CounterChecks.markdown for more details.

### First Run

Run PrivCount in share keeper mode so that it generates keys.

Use the commands under Tally Server First Run and Launch on Boot, but use sk
rather than ts.

### Autogenerated Keys

You MUST NOT use test keys for deployment: generate new keys for each network.

On first run, PrivCount creates the keys that it needs to run:

Each ShareKeeper creates a RSA key pair for public key encryption:
    * each DataCollector needs to know the SHA256 hash of the public key of
      each ShareKeeper.
    * to find the fingerprints, read the Share Keeper logs, or use the
      command below,
    * sign and send the fingerprint to each Data Collector.
    
To manually find Share Keeper key fingerprints, use:

    openssl rsa -pubout < keys/sk.pem | openssl dgst -sha256 | cut -d" " -f2

See doc/PrivCountAuthentication.markdown for more details.

## Data Collectors

You need one PrivCount DataCollector per tor relay.

### Configuration

#### Relay Creation

If you are setting up your relays for the first time, we recommend you use a
script to create consistent relay configs. Debian and Ubuntu have:

    tor-instance-create

It creates a --defaults-torrc file in /etc/tor, and individual torrc files and
systemd configs for each relay.

If your distribution doesn't come with a script like this, we recommend you
configure your tor relays using a --defaults-torrc file for common settings:

    tor --defaults-torrc /etc/tor/torrc-defaults

#### Automatic Configuration

By default, PrivCount sets ```EnablePrivCount 1``` when it starts a collection round,
and turns it off at the end of the round. When PrivCount is collecting data, it sets
```__ReloadTorrcOnSIGHUP 0``` to prevent the PrivCount option being turned off by a
HUP. This means that you can't change any torrc options during a collection.

If the data collectors are configured with ```use_sertconf: false```, you must set
 ```EnablePrivCount 1``` in the torrc for each relay. This allows multiple simultaneous
 collections by different projects, using the same relays. Having EnablePrivCount on all
 the time might cause some bias towards long-running connections, circuits, or
 streams. But we think these biases are small.

#### Name

PrivCount uses the name supplied by each node to uniquely identify it.
Each Data Collector must be configured with a unique 'name:' in config.yaml.
(Share Keepers use their public key hash as their name, so it is automatically
unique.)

Node names that are longer than 20 characters will be abbreviated in most
Tally Server log messages.

Configure each data collector with a unique name:

```
data_collector:
    name: 'MyRelayNickname'
```

#### Tally Server Address

Add the following Tally Server details to the config.yaml:

```
data_collector:
    tally_server_info:
        ip: 'IP address'
        port: port
```

#### Tor Control Port

PrivCount securely authenticates to tor's control port. This prevents the
control port being used to run commands as the tor user.

You can either configure a unix socket or a TCP port:

Unix Socket (more secure):

torrc:

```
ControlPort 'unix:/var/run/tor/control'
```

config.yaml:

```
data_collector:
    event_source:
        unix: '/var/run/tor/control'
```

TCP Port:

torrc:

```
ControlPort 20003
```

config.yaml:

```
data_collector:
    event_source:
        port: 20003
```

Cookie authentication requires the PrivCount user to have read access to tor's
cookie file.Password authentication requires a shared secret configured using
the event_source's control_password option.

Cookie Authentication (more secure, simpler):

torrc:
```
CookieAuthentication 1
```

config.yaml:

(automatic, no config required)

Password Authentication:

```
cat /dev/random | hexdump -e '"%x"' -n 32 -v > control_password.txt
tor --hash-password `cat control_password.txt`
```

torrc:

```
HashedControlPassword (output of tor --hash-password)
```

config.yaml:

```
data_collector:
    event_source:
        control_password: 'control_password.txt'
```

#### Key Configuration

Place the privcount.secret_handshake.yaml file from the Tally Server in the
Data Collector's working directory.

Add the Share Keepers' public key fingerprints to the config:

```
data_collector:
    share_keepers:
        - '0e193e4a66cf0332bc64ad613bb651579a10e08afdbb54aa49e9ea2286ccd41c'
        - '3f0f909d1c9b4aaa69e305404b916928f076ee9ea7940a4549550feb3276f676'
```

See doc/PrivCountAuthentication.markdown for more details.

#### Collection Configuration

```
data_collector:
    delay_period: 86400
```

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, it should be the same as the Tally Server's.

See doc/CounterChecks.markdown for more details.

### First Run

#### PrivCount-Patched Tor

Start your PrivCount-patched tor relays.
If you need to install a PrivCount-patched tor, see the instructions in
INSTALL.markdown.

If you are using systemd, use the systemd drop in file in:

    dist/systemd_privcount_tor.conf

to make your relays run a PrivCount-patched Tor binary.

Otherwise, use crontab or your distribution's service configuration to start
the relay, or start it manually:

    screen
    /usr/local/bin/tor -f /path/to/torrc --defaults-torrc /path/to/torrc-defaults 2>&1 | tee -a tor.log

If Control Port connections fail, PrivCount doesn't issue any warnings
straight away. As far as we can tell, the (legacy) connection API that
PrivCount uses doesn't provide callbacks or exceptions. See issue #303
for more details.

As a workaround, PrivCount will log warnings on both the data collector and
tally server when:
* the control port connection has not been successfully completed, and
* the aggregator stops receiving events for a long period of time
  (an hour or two).

For more details and troubleshooting steps, see
doc/TorControlAuthentication.markdown.

#### PrivCount

Then run PrivCount in data collector mode.

Use the commands under Tally Server First Run and Launch on Boot, but use dc
rather than ts.

When a threshold of data collectors are alive, the tally server will start
collection.
